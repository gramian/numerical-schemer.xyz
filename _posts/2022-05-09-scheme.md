---
title: "Why Scheme?"
date: 2022-05-09
tags: Scheme matrico
---

## Why is `matrico` developed in Scheme?

`matrico` is a passion project, written in the language, I came to enjoy programming in most: [Scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language)). 
Originally, I planned to develop a matrix focussed domain-specific language (DSL),
so I arrived first at [Racket](https://racket-lang.org) promoting [language-oriented programming](https://en.wikipedia.org/wiki/Language-oriented_programming),
then I tried [Common Lisp](https://lisp-lang.org) before finally arriving at Scheme. 
I then started `matrico` as a practical means of learning and improving an actual Scheme code. 
However, Lisps and Schemes are classically known for symbolic, not numerically compute capabilities, and modernly numerical libraries are still not too common.
So `matrico` is filling a niche, I naturally feel drawn to as a numerical mathematician. {: .text-justify}

### Lisp

Scheme is a [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)) (originally LISP, for LISt Processor);
which was invented by [J.McCarthy](https://lisp.org) in 1958 (see: [doi:10.1145/367177.367199](https://doi.org/10.1145/367177.367199) or: [www-formal.stanford.edu/jmc/recursive.html](http://www-formal.stanford.edu/jmc/recursive.html) ),
and as such it is the second oldest programming language after FORTRAN.
On the one hand, Lisp(s) are based on polish notation [S-expressions](https://en.wikipedia.org/wiki/S-expression),
which results in a simple, unambiguous syntax, without operator precendence rules, and lists as the basic data structure.
On the other hand, Lisp(s) encourage [functional programming](https://en.wikipedia.org/wiki/Functional_programming),
which means the use of pure functions, immutability of bindings, map/reduce concepts, and recursion instead of loops. {: .text-justify}

### Scheme

Scheme (short for Schemer, abbreviated due to a technical six character limit) was invented by G.L.Steele and G.J.Sussman in 1975,
is a standardized minimalistic dialect of Lisp.
For the interested reader, here are these Scheme "standards": {: .text-justify}

* [R0RS - SCHEME: An Interpreter for Extended Lambda Calculus](http://hdl.handle.net/1721.1/5794) (1975)
* [R1RS - Revised Scheme Report](http://hdl.handle.net/1721.1/6424) (1978)
* [R2RS - Revised^2 Scheme Report](https://hdl.handle.net/1721.1/5600) (1985)
* [R3RS - Revised^3 Scheme Report](https://doi.org/10.1145/15042.15043) (1986)
* [IEEE/ANSI Scheme Standard](https://doi.org/10.1109/IEEESTD.1991.101032) (1991)
* [R4RS - Revised^4 Scheme Report](https://doi.org/10.1145/382130.382133) (1991)
* [R5RS - Revised^5 Scheme Report](https://doi.org/10.1145/290229.290234) (1998)
* [ER^5RS - Extended Revised^5 Scheme Report](https://web.archive.org/web/20131225021348/http://scheme-punks.org/wiki/index.php?title=ERR5RS:Charter) (2007)
* [R6RS - Revised^6 Scheme Report](https://r6sr.org) (2007)
* [R7RS - Revised^7 Scheme Report](https://r7sr.org) (2013)

In summary, Scheme is interpreted (or compiled), dynamically but strictly typed, [lexically scoped](https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping_and_dynamic_scoping), and eagerly evaluated.
Scheme originates mainly from Lisp, but also from [ALGOL](https://en.wikipedia.org/wiki/ALGOL) and [Planner](https://en.wikipedia.org/wiki/Planner_(programming_language)).
Essentially, Scheme reflects [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus),
and also features [tail recursion](https://en.wikipedia.org/wiki/Tail_call), [hygenic macros](https://en.wikipedia.org/wiki/Hygienic_macro),
as well as typically an interactive environment, a so-called REPL (Read-Evaluate-Print-Loop).
Due to the minimality of Scheme (i.e. R5RS has merely 50 pages), there is also a set of reviewed implementation-agnostic extension libraries defined, see: {: .text-justify}

* [SRFI - Scheme Requests for Implementation](https://srfi.schemers.org)

Scheme used to be a widely spread language taught at universites, likely due to the exceptional computer science text book
[SICP - Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html),
which employs Scheme.
Nowadays, Scheme seems not too popular, i.e. the current TIOBE index (April 2022) is below 50,
with an all-time high of 15 (June 2002).
However, Scheme is still very much alive. {: .text-justify}

To get a feel for the Scheme language, check [Category:Scheme - Rosetta Code](https://rosettacode.org/wiki/Category:Scheme). {: .text-justify}

All in all, I was looking for a minimalistic language, with clear syntax that makes functional programming natural, hence I chose Scheme.
The particular Scheme impementation I selected for developing `matrico` is [CHICKEN Scheme](http://call-cc.org), whose advantages will be explained in the next blog post. {: .text-justify}

